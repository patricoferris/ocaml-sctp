open Util
open Sctp

(* Some tests borrowed from https://github.com/pion/sctp/blob/master/packet_test.go *)
let packet = Alcotest.testable Packet.pp Packet.equal

let test_parse buff expected () =
  let p = Packet.of_cstruct buff in
  Alcotest.(check (result packet msg)) "same packet" expected p

let test_encode_decode buff () =
  let p = Packet.of_cstruct buff in
  let buff' = Result.map Packet.to_cstruct p in
  Alcotest.(check (result cstruct msg)) "same buff" (Ok buff) buff'

let packets =
  [
    ( "header_only",
      list_to_cstruct
        [
          0x13; 0x88; 0x13; 0x88; 0x00; 0x00; 0x00; 0x00; 0x06; 0xa9; 0x00; 0xe1;
        ],
      Ok
        Packet.
          {
            header =
              Common_header.
                {
                  src_port = 5000;
                  dst_port = 5000;
                  verification_tag = 0l;
                  checksum = 111739105l;
                };
            chunks = [];
          } );
          ("packet", list_to_cstruct [
            (* Header *)
            0x13; 0x88; 0x13; 0x88; 0x00; 0x00; 0x00; 0x00; 0x00; 0xbc; 0x4f; 0xf2;
            (* Chunks *)
            0x01; 0x00; 0x00; 0x56; 0x55; 0xb9; 0x64; 0xa5; 0x00; 0x02; 0x00; 0x00;
            0x04; 0x00; 0x08; 0x00; 0xe8; 0x6d; 0x10; 0x30; 0xc0; 0x00; 0x00; 0x04; 
            0x80; 0x08; 0x00; 0x09; 0xc0; 0x0f; 0xc1; 0x80; 0x82; 0x00; 0x00; 0x00; 
            0x80; 0x02; 0x00; 0x24; 0x9f; 0xeb; 0xbb; 0x5c; 0x50; 0xc9; 0xbf; 0x75; 
            0x9c; 0xb1; 0x2c; 0x57; 0x4f; 0xa4; 0x5a; 0x51; 0xba; 0x60; 0x17; 0x78; 
            0x27; 0x94; 0x5c; 0x31; 0xe6; 0x5d; 0x5b; 0x09; 0x47; 0xe2; 0x22; 0x06; 
            0x80; 0x04; 0x00; 0x06; 0x00; 0x01; 0x00; 0x00; 0x80; 0x03; 0x00; 0x06;
            0x80; 0xc1; 0x00; 0x00;], Ok
            Packet.
              {
                header =
                  Common_header.
                    {
                      src_port = 5000;
                      dst_port = 5000;
                      verification_tag = 0l;
                      checksum = 12341234l;
                    };
                chunks = Chunk.[
                  {type_ = `Type INIT;
                  flags = 0;
                  payload = list_to_cstruct [0x55; 0xb9; 0x64; 0xa5; 0x00; 0x02; 0x00; 0x00;
                  0x04; 0x00; 0x08; 0x00; 0xe8; 0x6d; 0x10; 0x30; 0xc0; 0x00; 0x00; 0x04; 
                  0x80; 0x08; 0x00; 0x09; 0xc0; 0x0f; 0xc1; 0x80; 0x82; 0x00; 0x00; 0x00; 
                  0x80; 0x02; 0x00; 0x24; 0x9f; 0xeb; 0xbb; 0x5c; 0x50; 0xc9; 0xbf; 0x75; 
                  0x9c; 0xb1; 0x2c; 0x57; 0x4f; 0xa4; 0x5a; 0x51; 0xba; 0x60; 0x17; 0x78; 
                  0x27; 0x94; 0x5c; 0x31; 0xe6; 0x5d; 0x5b; 0x09; 0x47; 0xe2; 0x22; 0x06; 
                  0x80; 0x04; 0x00; 0x06; 0x00; 0x01; 0x00; 0x00; 0x80; 0x03; 0x00; 0x06;
                  0x80; 0xc1];
                  }
                ]})
  ][@@ocamlformat "disable"]

let init_params = list_to_cstruct 
  [ 0x55; 0xb9; 0x64; 0xa5; (* init tag *)
    0x00; 0x02; 0x00; 0x00; (* window *)
    0x04; 0x00; (* outbound *)
    0x08; 0x00; (* inbound *)
    0xe8; 0x6d; 0x10; 0x30; (* initial tsn *)
    0x00; 0x05; 0x00; 0x08; 
    0x80; 0x08; 0x00; 0x09; ][@@ocamlformat "disable"]

let chunk_init = Alcotest.testable Chunk.Init.pp Chunk.Init.equal

let read_chunk () =
  let c = Chunk.Init.of_cstruct init_params in
  let expect =
    Chunk.Init.
      {
        init_tag = 1438213285l;
        a_rwnd = 131072l;
        outbound = 1024;
        inbound = 2048;
        initial_tsn = Int32.of_int 3899461680;
        params =
          Params.
            [
              {
                type_ = `Type IPV4;
                value = list_to_cstruct [ 0x80; 0x08; 0x00; 0x09 ];
              };
            ];
      }
  in
  let b = Result.map Chunk.Init.to_cstruct c in
  Alcotest.(check (result chunk_init msg)) "same chunk" (Ok expect) c;
  Alcotest.(check (result cstruct msg)) "same buff" (Ok init_params) b

let tests =
  let open Alcotest in
  let decoding =
    List.map
      (fun (s, buff, packet) ->
        test_case (Fmt.str "dec_%s" s) `Quick (test_parse buff packet))
      packets
  in
  let encdec =
    List.map
      (fun (s, buff) ->
        test_case (Fmt.str "encdec_%s" s) `Quick (test_encode_decode buff))
      (List.map (fun (a, b, _) -> (a, b)) packets)
  in
  decoding @ encdec @ [ test_case "same chunk init" `Quick read_chunk ]
